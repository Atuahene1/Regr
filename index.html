<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=400, initial-scale=1.0">
    <title>Regression Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(120deg, #f9f9f9 60%, #e0e7ff 100%);
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2 {
            margin-top: 30px;
            letter-spacing: 2px;
        }
        #controls {
            margin-top: 18px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
            padding: 16px 24px;
            display: flex;
            gap: 18px;
            align-items: center;
        }
        #canvas-container {
            background: #fff;
            border: 2px solid #ccc;
            border-radius: 10px;
            margin-top: 20px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #f3f3f3;
            border-radius: 8px;
            cursor: pointer;
        }
        #tooltip {
            position: absolute;
            pointer-events: none;
            background: #222;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 15px;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
        }
        button {
            background: #6366f1;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 7px 16px;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #4f46e5;
        }
        label {
            font-weight: 500;
        }
    </style>
</head>
<body>
    <h2>Regression Visualization</h2>
    <div id="controls">
    <label for="numPoints">Points:</label>
    <select id="numPoints"></select>
    <label for="kSelect">k Nearest:</label>
    <select id="kSelect"></select>
    <button id="randomizeBtn">Randomize</button>
    <label><input type="checkbox" id="dragMode"> Drag Points</label>
    </div>
    <div id="canvas-container">
        <canvas id="regressionCanvas" width="500" height="350"></canvas>
    </div>
    <div id="tooltip"></div>
    <script>
        // --- Utility ---
        function lerp(a, b, t) { return a + (b - a) * t; }
        function colorForValue(val, min, max) {
            // Blue (low) to Red (high)
            const t = (val - min) / (max - min);
            const r = Math.round(lerp(70, 230, t));
            const g = Math.round(lerp(130, 30, t));
            const b = Math.round(lerp(220, 70, t));
            return `rgb(${r},${g},${b})`;
        }

        // --- KNN Utility ---
        function getKNearest(point, allPoints, k) {
            // Returns indices of k nearest neighbors (excluding self)
            const dists = allPoints.map((pt, idx) => ({
                idx,
                dist: Math.hypot(pt.x - point.x, pt.y - point.y)
            }));
            dists.sort((a, b) => a.dist - b.dist);
            // dists[0] is always self
            return dists.slice(1, k + 1).map(d => d.idx);
        }

        // --- DOM Elements ---
        const numPointsSelect = document.getElementById('numPoints');
        const canvas = document.getElementById('regressionCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
    const randomizeBtn = document.getElementById('randomizeBtn');
    const dragMode = document.getElementById('dragMode');
    const kSelect = document.getElementById('kSelect');

        // --- State ---
        let points = [];
        let animating = false;
        let dragIdx = null;
        let offsetX = 0, offsetY = 0;

        // --- Generate Points ---
        function generatePoints(n) {
            const arr = [];
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const radius = 110 + Math.random() * 70;
                const cx = 250, cy = 175;
                const x = cx + Math.cos(angle) * radius + (Math.random() * 30 - 15);
                const y = cy + Math.sin(angle) * radius + (Math.random() * 30 - 15);
                const value = +(Math.random() * 5 + 1).toFixed(2);
                arr.push({ x, y, value });
            }
            return arr;
        }

        // --- Animate Points ---
        function animateTo(newPoints) {
            animating = true;
            const steps = 18;
            let frame = 0;
            const startPoints = points.map(pt => ({...pt}));
            function step() {
                frame++;
                points = points.map((pt, i) => ({
                    x: lerp(startPoints[i].x, newPoints[i].x, frame/steps),
                    y: lerp(startPoints[i].y, newPoints[i].y, frame/steps),
                    value: lerp(startPoints[i].value, newPoints[i].value, frame/steps)
                }));
                draw();
                if (frame < steps) requestAnimationFrame(step);
                else {
                    points = newPoints;
                    animating = false;
                    draw();
                }
            }
            step();
        }

        // --- Linear Regression ---
        function getRegressionLine(pts) {
            // Least squares: y = a + bx
            const n = pts.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            for (const pt of pts) {
                sumX += pt.x;
                sumY += pt.y;
                sumXY += pt.x * pt.y;
                sumXX += pt.x * pt.x;
            }
            const b = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const a = (sumY - b * sumX) / n;
            return { a, b };
        }

        // --- Draw ---
    // knearest state
    let knnState = { idx: null, neighbors: [] };
    let K = 3; // Number of neighbors (default)
    function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw regression line
            if (points.length > 1) {
                const {a, b} = getRegressionLine(points);
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(0, a + b * 0);
                ctx.lineTo(canvas.width, a + b * canvas.width);
                ctx.strokeStyle = "#6366f1";
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 6]);
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            // Draw lines between points
            if (points.length > 1) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.strokeStyle = "#bbb";
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }
            // Draw k-nearest zone if active
            if (knnState.idx !== null && knnState.neighbors.length > 0) {
                ctx.save();
                ctx.globalAlpha = 0.18;
                ctx.beginPath();
                ctx.moveTo(points[knnState.idx].x, points[knnState.idx].y);
                knnState.neighbors.forEach(i => ctx.lineTo(points[i].x, points[i].y));
                ctx.closePath();
                ctx.fillStyle = '#6366f1';
                ctx.fill();
                ctx.globalAlpha = 1;
                // Draw lines to neighbors
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 2.5;
                knnState.neighbors.forEach(i => {
                    ctx.beginPath();
                    ctx.moveTo(points[knnState.idx].x, points[knnState.idx].y);
                    ctx.lineTo(points[i].x, points[i].y);
                    ctx.stroke();
                });
                ctx.restore();
            }
            // Draw points
            const minVal = Math.min(...points.map(p=>p.value));
            const maxVal = Math.max(...points.map(p=>p.value));
            points.forEach((pt, idx) => {
                ctx.save();
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 24, 0, 2 * Math.PI);
                if (knnState.idx === idx) {
                    ctx.fillStyle = '#6366f1';
                } else if (knnState.neighbors.includes(idx)) {
                    ctx.fillStyle = '#a5b4fc';
                } else {
                    ctx.fillStyle = colorForValue(pt.value, minVal, maxVal);
                }
                ctx.shadowColor = "#6366f1";
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.lineWidth = 2.5;
                ctx.strokeStyle = "#222";
                ctx.stroke();
                ctx.closePath();
                ctx.restore();
                // Value
                ctx.save();
                ctx.font = 'bold 17px Arial';
                ctx.fillStyle = "#fff";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pt.value.toFixed(2), pt.x, pt.y);
                ctx.restore();
            });
        }

        // --- Tooltip ---
        function showTooltip(x, y, text) {
            tooltip.style.left = (canvas.getBoundingClientRect().left + x + 12) + "px";
            tooltip.style.top = (canvas.getBoundingClientRect().top + y - 10) + "px";
            tooltip.textContent = text;
            tooltip.style.opacity = 1;
        }
        function hideTooltip() {
            tooltip.style.opacity = 0;
        }

        // --- Events ---
        canvas.addEventListener('mousemove', function(e) {
            if (animating) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            let found = false;
            points.forEach((pt, idx) => {
                if (Math.hypot(pt.x - x, pt.y - y) < 24) {
                    showTooltip(pt.x, pt.y, `Value: ${pt.value.toFixed(2)} (x: ${pt.x.toFixed(1)}, y: ${pt.y.toFixed(1)})`);
                    // KNN highlight
                    knnState.idx = idx;
                    knnState.neighbors = getKNearest(pt, points, K);
                    draw();
                    found = true;
                }
            });
            if (!found) {
                hideTooltip();
                knnState.idx = null;
                knnState.neighbors = [];
                draw();
            }
        });
        canvas.addEventListener('mouseleave', function() {
            hideTooltip();
            knnState.idx = null;
            knnState.neighbors = [];
            draw();
        });

        // Dragging
        canvas.addEventListener('mousedown', function(e) {
            if (!dragMode.checked || animating) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            for (let i = 0; i < points.length; i++) {
                if (Math.hypot(points[i].x - x, points[i].y - y) < 24) {
                    dragIdx = i;
                    offsetX = points[i].x - x;
                    offsetY = points[i].y - y;
                    break;
                }
            }
        });
        canvas.addEventListener('mousemove', function(e) {
            if (dragIdx !== null && dragMode.checked && !animating) {
                const rect = canvas.getBoundingClientRect();
                let x = e.clientX - rect.left, y = e.clientY - rect.top;
                // Clamp to canvas
                x = Math.max(24, Math.min(canvas.width - 24, x + offsetX));
                y = Math.max(24, Math.min(canvas.height - 24, y + offsetY));
                points[dragIdx].x = x;
                points[dragIdx].y = y;
                draw();
            }
        });
        window.addEventListener('mouseup', function() {
            dragIdx = null;
        });

        // --- Controls ---
        for (let i = 3; i <= 12; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = i;
            numPointsSelect.appendChild(opt);
        }
        numPointsSelect.value = 6;

        // kSelect: allow 1 to 6
        for (let i = 1; i <= 6; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = i;
            kSelect.appendChild(opt);
        }
        kSelect.value = 3;

        numPointsSelect.addEventListener('change', function() {
            const newPts = generatePoints(Number(this.value));
            animateTo(newPts);
        });

        kSelect.addEventListener('change', function() {
            K = Number(this.value);
            // Redraw to update knn zone if hovering
            draw();
        });

        randomizeBtn.addEventListener('click', function() {
            const newPts = generatePoints(points.length);
            animateTo(newPts);
        });

        dragMode.addEventListener('change', function() {
            if (!this.checked) dragIdx = null;
        });

        // --- Init ---
        points = generatePoints(Number(numPointsSelect.value));
        draw();
    </script>
</body>
</html>
